## 练习1

实现过程：设置trapframe的工作主要就是完成各个段寄存器的初始化，还有初始化进程使用的栈结构以及起始地址等上下文结构。将cs设置为USER_CS，ds,es,ss均设为USER_DS，使其拥有用户特权级。esp为用户栈的顶端，eip为程序的入口地址，eflags寄存器中打开中断位即可。

用户进程执行过程：当进程变为RUNNING态时，proc_run函数会载入进程的kstack和cr3页表，调用switch_to函数进行切换，在switch.S中调用汇编代码。这段代码会将进程当前执行到的eip压栈，然后用一条ret跳转到eip处执行。之前load_icode已经把eip设为了程序的entry处，且已经设置好了用户态的trapframe和对应的段寄存器。这样执行完ret以后跳到用户程序的入口地址执行，其就工作在用户态。

## 练习2

实现COW机制：在父进程fork子进程时，可以将子进程的cr3寄存器设为与自己相同，同时将自己拥有的页表项PTE_W都设为0即只读，这样父进程与子进程都可以读取相同的页面。而当某个进程试图写这个页面时，会引发page fault异常，此时在中断服务例程中检查是否是copy on write的情况，即调用copy_range函数拷贝对应的页面到一个新的内存空间让进程完成写操作。

## 练习3

1. 各函数对进程的执行状态影响

do_fork中会对进程进行初始化，然后调用wakup_proc函数将进程状态设置为RUNNABLE等待分配时间片。

do_execve中没有修改进程的状态，仅仅拷贝了可执行二进制代码。

do_wait中会对进程的子进程进行检测，如果其子进程都已经结束或都是僵尸进程，则直接结束这个进程释放资源。如果其子进程还没有结束，则将其置于SLEEPING状态。

do_exit中会释放一个进程所占用的资源，将其变为ZOMBIE状态，然后判断其父进程是否处于等待状态（WT_CHILD），如果是则调用wakeup_proc唤醒父进程。若此进程含有子进程，则将子进程交由内核线程initproc处理。

do_kill中会直接唤醒进程并将其eflags中的PF_EXITING位置1，强制进程退出。

2. 用户态进程的执行状态图

···

                                                      PROC_ZOMBIE <-------------------------
                                                        ^                                  |
                                                        |                                  | 
                                                        |                                  |
                                                        |                                  |
                                                        | do_exit                          | do_exit
                                                        |                                  |
                                                        |                                  |
                                                        |                                  |
   alloc_proc                   do_fork/wakeup_proc     |                 do_wait          |
----------------> PROC_UNINIT ----------------------> PROC_RUNNABLE -----------------> PROC_SLEEPING
                                                        |           <-----------------
                                                        |                 do_exit  
                                                        |
                                                        |
                                                        |
                                                        | do_wait
                                                        |
                                                        |
                                                        |
                                                       \ /
                                                     (freed)
···

## 实验中的知识点

实验中对用户进程的产生过程以及执行方式讲解的非常详细，由于有lab4的框架支持，实现起来也并不困难。能够很好地理解用户态进程的各种执行状态以及切换关系，之前的段机制、特权级描述都在切换用户态中起到了作用。

## 原理课中的知识点

原理课中提到了进程PCB的组织方式队列，在实验中没有很好地体现。且对于进程调度的方式也没有讲解。且实验中使用proc_struct统一管理线程和进程，如何区分它们以及实现没有给出答案。
